//
// _SpecDoc_cpp_
//
// Copyright (C) 2017-2018 Tactical Computing Laboratories, LLC
// All Rights Reserved
// contact@tactcomplabs.com
//
// See LICENSE in the top level directory for licensing details
//

#include "CoreGen/CoreGenBackend/Passes/Data/SpecDoc.h"

SpecDoc::SpecDoc(std::ostream *O,
                     CoreGenDAG *D,
                     CoreGenErrno *E)
  : CoreGenPass(CGPassData,3,"SpecDoc",
                "Generates a LaTeX Spec Document",false,O,D,E){
}

SpecDoc::~SpecDoc(){
}

bool SpecDoc::WriteMakefile() {
  // build the output file name
  std::string OFile = this->GetOutputPath() + "/Makefile";
  bool PrevFile = false;

  if( CGFileExists(OFile) ){
    PrevFile = true;
    CGFileCopy( OFile,
                OFile + ".back" );
    CGDeleteFile(OFile);
  }

  std::ofstream ofs;
  ofs.open(OFile.c_str(), std::ofstream::out | std::ofstream::app);

  ofs << "#!/bin/sh" << std::endl;
  ofs << "#" << std::endl;
  ofs << "# Spec Document Makefile" << std::endl;
  ofs << "# Auto-generated by the System Architect CoreGen SpecDoc Data Pass" << std::endl;
  ofs << "# " << CGCurrentDateTime() << std::endl;
  ofs << "#" << std::endl;
  ofs << "DOC = spec" << std::endl;
  ofs << "TEX = $(wildcard *.tex)" << std::endl;
  ofs << "FIGS = $(wildcard figures/*.pdf figures/*.png figures/*.jpg)" << std::endl;
  ofs << std::endl;
  ofs << ".PHONY: all clean" << std::endl;
  ofs << std::endl;
  ofs << "$(DOC).pdf: $(TEXT) $(FIGS)" << std::endl;
  ofs << "\techo $(FIGS)" << std::endl;
  ofs << "\tpdflatex $(DOC)" << std::endl;
  ofs << "\tpdflatex $(DOC)" << std::endl;
  ofs << "\tpdflatex $(DOC)" << std::endl;
  ofs << "clean:" << std::endl;
  ofs << "\trm -f *.aux *.bbl *.blg *.log *.lof *.lol *.lot *.out *.toc $(DOC).pdf" << std::endl;

  ofs.close();

  if( PrevFile ){
    CGDeleteFile(OFile + ".back");
  }
  return true;
}

bool SpecDoc::WriteOverviewTex(CoreGenDAG *DAG, std::ofstream &ofs ){
  ofs << "\% ---------------------------------------------------------------" << std::endl;
  ofs << "\% OVERVIEW" << std::endl;
  ofs << "\% ---------------------------------------------------------------" << std::endl;
  ofs << "\\clearpage" << std::endl;
  ofs << "\\section{Overview}" << std::endl;
  ofs << "\\label{sec:Overview}" << std::endl;

  ofs << "This specification document was auto-generated by the System Architect " << std::endl
      << " CoreGen infrastructure.  Any changes to this file will be automatically " << std::endl
      << " overwritten by CoreGen." << std::endl;

  ofs << std::endl << std::endl;

  return true;
}

bool SpecDoc::WriteRegisterClassTex(CoreGenDAG *DAG, std::ofstream &ofs ){
  ofs << "\% ---------------------------------------------------------------" << std::endl;
  ofs << "\% REGISTER CLASSES" << std::endl;
  ofs << "\% ---------------------------------------------------------------" << std::endl;
  ofs << "\\clearpage" << std::endl;
  ofs << "\\section{Register Classes}" << std::endl;
  ofs << "\\label{sec:RegisterClasses}" << std::endl;

  for( unsigned i=0; i<DAG->GetDimSize(); i++ ){
    CoreGenNode *N = DAG->FindNodeByIndex(i);
    if( N->GetType() == CGRegC ){
      CoreGenRegClass *RC = static_cast<CoreGenRegClass *>(N);
      ofs << "\\subsection{Register Class: " << RC->GetName() << "}" << std::endl;
      ofs << "\\label{sec:" << RC->GetName() << "}" << std::endl;

      ofs << "The following table represents the registers configured in the "
          << RC->GetName() << " register class." << std::endl;

      // tabulate all the info on the registers
      ofs << std::endl << std::endl;
      ofs << "\\begin{table}[h]" << std::endl;
      ofs << "\\begin{center}" << std::endl;
      ofs << "\\caption{" << RC->GetName() << " Registers}" << std::endl;
      ofs << "\\label{tab:" << RC->GetName() << "Registers}" << std::endl;
      ofs << "\\begin{tabular}{c c c c c c c c}" << std::endl;
      ofs << "\\hline" << std::endl;
      ofs << "\\textbf{Name} & \\textbf{Index} & \\textbf{Width} & "
          << "\\textbf{Attrs} & \\textbf{SIMD} & \\textbf{SIMD Width} & "
          << "\\textbf{PseudoName} & \\textbf{FixedValue}\\\\" << std::endl;
      ofs << "\\hline" << std::endl;

      for( unsigned j=0; j<RC->GetNumReg(); j++ ){
        CoreGenReg *REG = RC->GetReg(j);

        std::string Attrs;
        bool OrVal = false;
        if( REG->IsRWAttr() ){
          Attrs+= "RW";
          OrVal = true;
        }
        if( REG->IsROAttr() ){
          if( OrVal ){
            Attrs+=":";
          }
          Attrs+="RO";
          OrVal = true;
        }
        if( REG->IsCSRAttr() ){
          if( OrVal ){
            Attrs+=":";
          }
          Attrs+="CSR";
          OrVal = true;
        }
        if( REG->IsAMSAttr() ){
          if( OrVal ){
            Attrs+=":";
          }
          Attrs+="AMS";
        }

        ofs << REG->GetName()   << " & "  << std::hex << "0x" << REG->GetIndex() << std::dec
            << " & "
            << REG->GetWidth()  << " & "  << Attrs            << " & ";
        if( REG->IsSIMD() ){
          ofs << "Y & " << REG->GetSIMDWidth() << " & ";
        }else{
          ofs << "N & 0 & ";
        }
        if( REG->GetPseudoName().length() > 0 ){
          ofs << REG->GetPseudoName() << " & ";
        }else{
          ofs << "NA & ";
        }
        if( REG->IsFixedValue() ){
          ofs << " Y & ";
          std::vector<uint64_t> Vals;
          REG->GetFixedVals(Vals);

          // TODO: this is wrong
          for( signed k=Vals.size(); k>=0; k-- ){
            ofs << Vals[k];
          }
          ofs << "\\\\" << std::endl;
        }else{
          ofs << " NA \\\\" << std::endl;
        }
      }

      ofs << "\\end{tabular}" << std::endl;
      ofs << "\\end{center}" << std::endl;
      ofs << "\\end{table}" << std::endl;
    }
  }

  return true;
}

std::string SpecDoc::GenerateInstFormatHeader(CoreGenInstFormat *IF){
  std::string Header;
  double base = 0.18;
  for( signed i=(IF->GetNumFields()-1); i>=0; i-- ){
    unsigned Width = IF->GetFieldWidth(IF->GetFieldName(i));
    if( Width == 0 ){
      Header+=" ";
    }else{
      double FieldWidth = ((IF->GetEndBit(IF->GetFieldName(i)) -
       IF->GetStartBit(IF->GetFieldName(i)))+1)*base;
      Header = Header + "p{" + std::to_string(FieldWidth) + "in}";
    }

    if( i!=0 ){
      Header += "@{}";
    }
  }
  return Header;
}

bool SpecDoc::WriteInstFormatTex(CoreGenDAG *DAG, std::ofstream &ofs ){
  ofs << "\% ---------------------------------------------------------------" << std::endl;
  ofs << "\% INSTRUCTION FORMATS" << std::endl;
  ofs << "\% ---------------------------------------------------------------" << std::endl;
  ofs << "\\clearpage" << std::endl;
  ofs << "\\section{Instruction Formats}" << std::endl;
  ofs << "\\label{sec:InstructionFormats}" << std::endl;

  for( unsigned i=0; i<DAG->GetDimSize(); i++ ){
    CoreGenNode *N = DAG->FindNodeByIndex(i);
    if( N->GetType() == CGInstF ){
      CoreGenInstFormat *IF = static_cast<CoreGenInstFormat *>(N);

      ofs << "\\subsection{InstructionFormat: " << IF->GetName() << "}" << std::endl;
      ofs << "\\label{sec:" << IF->GetName() << "}" << std::endl;
      ofs << std::endl << std::endl;

      ofs << "The following diagrams represent the " << IF->GetName()
          << " instruction format from the " << IF->GetISA()->GetName()
          << " instruction set architecture." << std::endl;

      // draw an instruction format block diagram
      ofs << "\\vspace{0.25in}" << std::endl;
      ofs << "\\begin{figure}[H]" << std::endl;
      ofs << "\\begin{center}" << std::endl;
      ofs << "\\begin{tabular}{" << GenerateInstFormatHeader(IF) << "}" << std::endl;
      ofs << "\\\\" << std::endl;

      // print all the bit ranges
      for( signed j=(IF->GetNumFields()-1); j>=0; j-- ){
        ofs << "\\instbitrange{" << IF->GetEndBit(IF->GetFieldName(j))
            << "}{" << IF->GetStartBit(IF->GetFieldName(j)) << "}";
        if( j!=0 ){
          ofs << " & " << std::endl;
        }else{
          ofs << "\\\\" << std::endl;
        }
      }

      ofs << "\\hline" << std::endl;

      // print the multicolumn data
      for( signed j=(IF->GetNumFields()-1); j>=0; j-- ){
        signed comp = IF->GetNumFields()-1;
        if( j==comp ){
          ofs << "\\multicolumn{1}{|c|}{"
              << IF->GetFieldName(j)
              << "} &" << std::endl;
        }else if (j==0){
          ofs << "\\multicolumn{1}{c|}{"
              << IF->GetFieldName(j)
              << "} \\\\" << std::endl;
          ofs << "\\hline" << std::endl;
        }else{
          ofs << "\\multicolumn{1}{c|}{"
              << IF->GetFieldName(j)
              << "} &" << std::endl;
        }
      }

      // print all the bit widths
      for( signed j=(IF->GetNumFields()-1); j>=0; j-- ){
        ofs << (IF->GetEndBit(IF->GetFieldName(j)) -
                IF->GetStartBit(IF->GetFieldName(j)))+1;
        if( j!=0 ){
          ofs << " & ";
        }else{
          ofs << "\\\\" << std::endl;
        }
      }

      // print all the field names
      for( signed j=(IF->GetNumFields()-1); j>=0; j-- ){
        ofs << IF->GetFieldName(j);
        if( j !=0 ){
          ofs << " & ";
        }else{
          ofs << "\\\\" << std::endl;
        }
      }

      //print the end of the table
      ofs << "\\end{tabular}" << std::endl;
      ofs << "\\end{center}" << std::endl;
      ofs << "\\caption{" << IF->GetName() << "}" << std::endl;
      ofs << "\\label{fig:" << IF->GetName() << "}" << std::endl;
      ofs << "\\end{figure}" << std::endl;

      ofs << std::endl << std::endl;

      // print all the field details
      ofs << "\\begin{table}[h]" << std::endl;
      ofs << "\\begin{center}" << std::endl;
      ofs << "\\caption{" << IF->GetName() << " Fields}" << std::endl;
      ofs << "\\label{tab:" << IF->GetName() << "Fields}" << std::endl;
      ofs << "\\begin{tabular}{|c | c | c | c | c | c|}" << std::endl;
      ofs << "\\hline" << std::endl;
      ofs << "\\textbf{Name} & \\textbf{EndBit} & \\textbf{StartBit} & "
          << "\\textbf{FieldType} & \\textbf{RegClass} & \\textbf{Mandatory?}\\\\"
          << std::endl;
      ofs << "\\hline" << std::endl;
      ofs << "\\hline" << std::endl;
      for( signed j=(IF->GetNumFields()-1); j>=0; --j ){
        ofs << IF->GetFieldName(j) << " & ";
        ofs << IF->GetEndBit(IF->GetFieldName(j)) << " & ";
        ofs << IF->GetStartBit(IF->GetFieldName(j)) << " & ";
        ofs << IF->CGInstFieldToStr(IF->GetFieldType(IF->GetFieldName(j)))
            << " & ";
        if( IF->GetFieldType(IF->GetFieldName(j)) == CoreGenInstFormat::CGInstReg){
          ofs << IF->GetFieldRegClass(IF->GetFieldName(j))->GetName()
              << " & ";
        }else{
          ofs << "N/A & ";
        }
        if( IF->GetMandatoryFlag(IF->GetFieldName(j)) ){
          ofs << " Yes \\\\" << std::endl;
        }else{
          ofs << " No \\\\" << std::endl;
        }
        ofs << "\\hline" << std::endl;
      }

      ofs << "\\end{tabular}" << std::endl;
      ofs << "\\end{center}" << std::endl;
      ofs << "\\end{table}" << std::endl;

      ofs << std::endl << std::endl;
    }
  }

  return true;
}

bool SpecDoc::WriteInstTex(CoreGenDAG *DAG, std::ofstream &ofs ){
  ofs << "\% ---------------------------------------------------------------" << std::endl;
  ofs << "\% INSTRUCTIONS " << std::endl;
  ofs << "\% ---------------------------------------------------------------" << std::endl;
  ofs << "\\clearpage" << std::endl;
  ofs << "\\section{Instructions}" << std::endl;
  ofs << "\\label{sec:Instructions}" << std::endl;

  for( unsigned i=0; i<DAG->GetDimSize(); i++ ){
    CoreGenNode *N = DAG->FindNodeByIndex(i);
    if( N->GetType() == CGInst ){
      CoreGenInst *INST = static_cast<CoreGenInst *>(N);

      ofs << "\\subsection{" << INST->GetName() << "}" << std::endl;
      ofs << "\\label{sec:" << INST->GetName() << "}" << std::endl;
      ofs << "The " << INST->GetName() << " instruction belongs to the "
          << INST->GetISA()->GetName() << " instruction set.  It has the following features:"
          << std::endl;

      // print an instruction table
      ofs << "\\begin{table}[h]" << std::endl;
      ofs << "\\begin{center}" << std::endl;
      ofs << "\\caption{" << INST->GetName() << " Information}" << std::endl;
      ofs << "\\label{tab:" << INST->GetName() << "INFO}" << std::endl;
      ofs << "\\begin{tabular}{c c c}" << std::endl;
      ofs << "\\hline" << std::endl;
      ofs << "\\textbf{General Info} & &\\\\" << std::endl;
      ofs << "\\hline" << std::endl;
      ofs << "Name & " << INST->GetName() << " &\\\\" << std::endl;
      ofs << "ISA & " << INST->GetISA()->GetName() << " &\\\\" << std::endl;
      ofs << "Instruction Format & " << INST->GetFormat()->GetName() << " &\\\\" << std::endl;
      ofs << "\\hline" << std::endl;

      ofs << "\\textbf{Encoding Info} & &\\\\" << std::endl;
      ofs << "\\textit{Field} & \\textit{Width(bits)} & \\textit{Value}\\\\" << std::endl;
      for( unsigned j=0; j<INST->GetNumEncodings(); j++ ){
        CoreGenEncoding *E = INST->GetEncoding(j);
        ofs << E->GetField() << " & "
            << E->GetLength() << " & "
            << std::hex << "0x" << E->GetEncoding() << std::dec << "\\\\" << std::endl;
      }

      ofs << "\\hline" << std::endl;
      ofs << "\\end{tabular}" << std::endl;
      ofs << "\\end{center}" << std::endl;
      ofs << "\\end{table}" << std::endl;

      ofs << std::endl << std::endl;

      // print the stonecutter source
      if( INST->IsImpl() ){
        ofs << "The instruction is described by the following StoneCutter source code:"
            << std::endl;
        ofs << std::endl;
        ofs << "\\vspace{0.125in}" << std::endl;
        ofs << "\\begin{lstlisting}[frame=single,style=base,caption={"
            << INST->GetName() << " StoneCutter Implementation"
            << "},captionpos=b,label={lis:"
            << INST->GetName()
            << "}]"
            << std::endl;
        ofs << INST->GetImpl() << std::endl;
        ofs << "\\end{lstlisting}" << std::endl;
        ofs << std::endl << std::endl;
      }
    }
  }

  return true;
}

bool SpecDoc::WritePseudoInstTex(CoreGenDAG *DAG, std::ofstream &ofs ){
  ofs << "\% ---------------------------------------------------------------" << std::endl;
  ofs << "\% PSEUDO INSTRUCTIONS" << std::endl;
  ofs << "\% ---------------------------------------------------------------" << std::endl;
  ofs << "\\clearpage" << std::endl;
  ofs << "\\section{Pseudo Instructions}" << std::endl;
  ofs << "\\label{sec:PseudoInstructions}" << std::endl;

  for( unsigned i=0; i<DAG->GetDimSize(); i++ ){
    CoreGenNode *N = DAG->FindNodeByIndex(i);
    if( N->GetType() == CGPInst ){
      CoreGenPseudoInst *INST = static_cast<CoreGenPseudoInst *>(N);

      ofs << "\\subsection{" << INST->GetName() << "}" << std::endl;
      ofs << "\\label{sec:" << INST->GetName() << "}" << std::endl;
      ofs << "The " << INST->GetName() << " pseudo instruction belongs to the "
          << INST->GetISA()->GetName() << " instruction set.  It is associated with the "
          << INST->GetInst()->GetName() << " instruction.  It has the following features:"
          << std::endl;

      // print an instruction table
      ofs << "\\begin{table}[h]" << std::endl;
      ofs << "\\begin{center}" << std::endl;
      ofs << "\\caption{" << INST->GetName() << " Information}" << std::endl;
      ofs << "\\label{tab:" << INST->GetName() << "INFO}" << std::endl;
      ofs << "\\begin{tabular}{c c c}" << std::endl;
      ofs << "\\hline" << std::endl;
      ofs << "\\textbf{General Info} & &\\\\" << std::endl;
      ofs << "\\hline" << std::endl;

      ofs << "Name & " << INST->GetName() << " &\\\\" << std::endl;
      ofs << "ISA & " << INST->GetISA()->GetName() << " &\\\\" << std::endl;
      ofs << "Instruction & " << INST->GetInst()->GetName()
          << "[Section \\ref{sec:" << INST->GetInst()->GetName() << "}] &\\\\" << std::endl;
      ofs << "Instruction Format & " << INST->GetInst()->GetFormat()->GetName() << " &\\\\" << std::endl;
      ofs << "\\hline" << std::endl;

      ofs << "\\textbf{Encoding Info} & &\\\\" << std::endl;
      ofs << "\\textit{Field} & \\textit{Width(bits)} & \\textit{Value}\\\\" << std::endl;
      for( unsigned j=0; j<INST->GetNumEncodings(); j++ ){
        CoreGenEncoding *E = INST->GetEncoding(j);
        ofs << E->GetField() << " & "
            << E->GetLength() << " & "
            << std::hex << "0x" << E->GetEncoding() << std::dec << "\\\\" << std::endl;
      }


      ofs << "\\hline" << std::endl;
      ofs << "\\end{tabular}" << std::endl;
      ofs << "\\end{center}" << std::endl;
      ofs << "\\end{table}" << std::endl;

      ofs << std::endl << std::endl;
    }
  }

  return true;
}

bool SpecDoc::WriteInstTableTex(CoreGenDAG *DAG, std::ofstream &ofs ){
  ofs << "\% ---------------------------------------------------------------" << std::endl;
  ofs << "\% INSTRUCTION TABLE" << std::endl;
  ofs << "\% ---------------------------------------------------------------" << std::endl;
  ofs << "\\clearpage" << std::endl;
  ofs << "\\section{Instruction Table}" << std::endl;
  ofs << "\\label{sec:InstructionTable}" << std::endl;

  return true;
}

bool SpecDoc::WriteTexfile(CoreGenDAG *DAG) {
  // build the output file name
  std::string OFile = this->GetOutputPath() + "/spec.tex";
  bool PrevFile = false;

  if( CGFileExists(OFile) ){
    PrevFile = true;
    CGFileCopy( OFile,
                OFile + ".back" );
    CGDeleteFile(OFile);
  }

  std::ofstream ofs;
  ofs.open(OFile.c_str(), std::ofstream::out | std::ofstream::app);

  // write out the header
  ofs << "\% ---------------------------------------------------------------" << std::endl;
  ofs << "\% spec.tex" << std::endl;
  ofs << "\% System Architect CoreGen Auto-generated Specification Document" << std::endl;
  ofs << "\% " << CGCurrentDateTime() << std::endl;
  ofs << "\% ---------------------------------------------------------------" << std::endl;
  ofs << std::endl << std::endl;
  ofs << "\% ---------------------------------------------------------------" << std::endl;
  ofs << "\% LATEX PACKAGES" << std::endl;
  ofs << "\% ---------------------------------------------------------------" << std::endl;
  ofs << "\\documentclass{article}" << std::endl;
  ofs << "\\usepackage[margin=1.0in]{geometry}" << std::endl;
  ofs << "\\usepackage{graphicx}" << std::endl;
  ofs << "\\usepackage{amsmath}" << std::endl;
  ofs << "\\usepackage[utf8]{inputenc}" << std::endl;
  ofs << "\\usepackage[english]{babel}" << std::endl;
  ofs << "\\usepackage[parfill]{parskip}" << std::endl;
  ofs << "\\usepackage{array}" << std::endl;
  ofs << "\\usepackage{algorithm}" << std::endl;
  ofs << "\\usepackage{listings}" << std::endl;
  ofs << "\\usepackage{xcolor}" << std::endl;
  ofs << "\\usepackage{courier}" << std::endl;
  ofs << "\\usepackage{colortbl}" << std::endl;
  ofs << "\\usepackage{placeins}" << std::endl;
  ofs << "\\usepackage{longtable}" << std::endl;
  ofs << "\\usepackage{multirow}" << std::endl;
  ofs << "\\usepackage{float}" << std::endl;
  ofs << "\\usepackage{caption}" << std::endl;
  ofs << "\\RequirePackage{epstopdf}" << std::endl;
  ofs << "\\RequirePackage{tabularx}" << std::endl;
  ofs << "\\RequirePackage{xstring}" << std::endl;
  ofs << "\\RequirePackage{hyperref}" << std::endl;
  ofs << "\\RequirePackage{fancyhdr}" << std::endl;

  ofs << std::endl << std::endl;

  ofs << "\\newcommand{\\note}[1]{{\\bf [ NOTE: #1 ]}}" << std::endl;

  // tabuluar column widths for instruction formats
#if 0
  ofs << "\\newcolumntype{I}{>{\\centering\\arraybackslash}p{0.18in}}" << std::endl;  // 1-bit
  ofs << "\\newcolumntype{W}{>{\\centering\\arraybackslash}p{0.36in}}" << std::endl;  // 2-bit
  ofs << "\\newcolumntype{F}{>{\\centering\\arraybackslash}p{0.54in}}" << std::endl;  // 3-bit
  ofs << "\\newcolumntype{Y}{>{\\centering\\arraybackslash}p{0.72in}}" << std::endl;  // 4-bit
  ofs << "\\newcolumntype{R}{>{\\centering\\arraybackslash}p{0.9in}}" << std::endl;   // 5-bit
  ofs << "\\newcolumntype{S}{>{\\centering\\arraybackslash}p{1.08in}}" << std::endl;  // 6-bit
  ofs << "\\newcolumntype{O}{>{\\centering\\arraybackslash}p{1.26in}}" << std::endl;  // 7-bit
  ofs << "\\newcolumntype{E}{>{\\centering\\arraybackslash}p{1.44in}}" << std::endl;  // 8-bit
  ofs << "\\newcolumntype{T}{>{\\centering\\arraybackslash}p{1.8in}}" << std::endl;   // 10-bit
  ofs << "\\newcolumntype{M}{>{\\centering\\arraybackslash}p{2.2in}}" << std::endl;   // 12-bit
  ofs << "\\newcolumntype{K}{>{\\centering\\arraybackslash}p{2.88in}}" << std::endl;  // 16-bit
  ofs << "\\newcolumntype{U}{>{\\centering\\arraybackslash}p{3.6in}}" << std::endl;   // 20-bit
  ofs << "\\newcolumntype{L}{>{\\centering\\arraybackslash}p{3.6in}}" << std::endl;   // 20-bit
  ofs << "\\newcolumntype{J}{>{\\centering\\arraybackslash}p{4.5in}}" << std::endl;   // 25-bit
#endif

  ofs << "\\newcommand{\\instbit}[1]{\\mbox{\\scriptsize #1}}" << std::endl;
  ofs << "\\newcommand{\\instbitrange}[2]{~\\instbit{#1} \\hfill \\instbit{#2}~}" << std::endl;
  ofs << "\\newcommand{\\reglabel}[1]{\\hfill {\\tt #1}\\hfill\\ }" << std::endl;
  ofs << "\\newcommand{\\wiri}{\\textbf{WIRI}}" << std::endl;
  ofs << "\\newcommand{\\wpri}{\\textbf{WPRI}}" << std::endl;
  ofs << "\\newcommand{\\wlrl}{\\textbf{WLRL}}" << std::endl;
  ofs << "\\newcommand{\\warl}{\\textbf{WARL}}" << std::endl;


  ofs << std::endl << std::endl;

  ofs << "\\setlength{\\parindent}{1em}" << std::endl;
  ofs << "\\setlength{\\parskip}{1em}" << std::endl;
  ofs << std::endl << std::endl;
  ofs << "\\lstdefinestyle{base}{" << std::endl;
  ofs << "\tlanguage=C++," << std::endl;
  ofs << "\tnumbers=left," << std::endl;
  ofs << "\tstepnumber=1," << std::endl;
  ofs << "\temptylines=1," << std::endl;
  ofs << "\tbreaklines=true," << std::endl;
  ofs << "\tbasicstyle=\\ttfamily\\color{black}," << std::endl;
  ofs << "\tmoredelim=**[is][\\color{red}]{@}{@}," << std::endl;
  ofs << "}" << std::endl;

  ofs << std::endl << std::endl;

  ofs << "\\hypersetup{" << std::endl;
  ofs << "\tcolorlinks=true," << std::endl;
  ofs << "\tlinktoc=all," << std::endl;
  ofs << "\tlinkcolor=black," << std::endl;
  ofs << "\tcitecolor=black," << std::endl;
  ofs << "\turlcolor=black" << std::endl;
  ofs << "}" << std::endl;

  ofs << std::endl << std::endl;

  ofs << "\\setlength\\parindent{0pt}" << std::endl;
  ofs << "\\renewcommand{\\labelenumi}{\\alph{enumi}.}" << std::endl;

  ofs << std::endl << std::endl;

  ofs << "\% ---------------------------------------------------------------" << std::endl;
  ofs << "\% DOCUMENT LAYOUT INFORMATION" << std::endl;
  ofs << "\% ---------------------------------------------------------------" << std::endl;
  ofs << "\\pagestyle{fancy}" << std::endl;
  ofs << "\\lhead{}" << std::endl;
  ofs << "\\chead{SPECIFICATION}" << std::endl;
  ofs << "\\rhead{}" << std::endl;
  ofs << "\\lfoot{" << CGCurrentDateTime() << "}" << std::endl;
  ofs << "\\cfoot{SPECIFICATION}" << std::endl;
  ofs << "\\rfoot{\\thepage}" << std::endl;

  ofs << std::endl << std::endl;

  ofs << "\% ---------------------------------------------------------------" << std::endl;
  ofs << "\% DOCUMENT INFORMATION" << std::endl;
  ofs << "\% ---------------------------------------------------------------" << std::endl;

  ofs << "\\title{Instruction Set Architecture Specification}" << std::endl;
  ofs << "\\author{Auto-Generated by System Architect CoreGen}" << std::endl;
  ofs << "\\date{}" << std::endl;

  ofs << "\\begin{document}" << std::endl;

  ofs << std::endl << std::endl;

  ofs << "\\maketitle" << std::endl;
  ofs << "\\thispagestyle{fancy}" << std::endl;

  ofs << std::endl << std::endl;

  ofs << "\\begin{center}" << std::endl;
  ofs << "\\begin{tabular}{l r}" << std::endl;
  ofs << "Date: & " << CGCurrentDateTime() << "\\\\" << std::endl;
  ofs << "Revision: 1.0 \\\\" << std::endl;
  ofs << "Authors: AutoGenerated by System Architect CoreGen \\\\" << std::endl;
  ofs << "\\end{tabular}" << std::endl;
  ofs << "\\end{center}" << std::endl;

  ofs << std::endl << std::endl;

  ofs << "\% ---------------------------------------------------------------" << std::endl;
  ofs << "\% TABLE OF CONTENTS" << std::endl;
  ofs << "\% ---------------------------------------------------------------" << std::endl;
  ofs << "\\clearpage" << std::endl;
  ofs << "\\tableofcontents" << std::endl;
  ofs << "\\clearpage" << std::endl;

  ofs << std::endl << std::endl;

  ofs << "\% ---------------------------------------------------------------" << std::endl;
  ofs << "\% LISTINGS" << std::endl;
  ofs << "\% ---------------------------------------------------------------" << std::endl;
  ofs << "\\clearpage" << std::endl;
  ofs << "\\listoffigures" << std::endl;
  ofs << "\\lstlistoflistings" << std::endl;
  ofs << "\\listoftables" << std::endl;

  bool rtn = true;

  //-- write the overview
  if( !WriteOverviewTex( DAG, ofs ) ){
    rtn = false;
  }

  //-- write the register classes
  if( !WriteRegisterClassTex( DAG, ofs ) ){
    rtn = false;
  }

  //-- writer the instruction formats
  if( !WriteInstFormatTex( DAG, ofs ) ){
    rtn = false;
  }

  //-- write the instructions
  if( !WriteInstTex( DAG, ofs ) ){
    rtn = false;
  }

  //-- write the pseudo instructions
  if( !WritePseudoInstTex( DAG, ofs ) ){
    rtn = false;
  }

  //-- write the instruction table
  if( !WriteInstTableTex( DAG, ofs ) ){
    rtn = false;
  }

  ofs << "\\clearpage" << std::endl;
  ofs << "\\end{document}" << std::endl;

  ofs.close();

  if( PrevFile ){
    CGDeleteFile(OFile + ".back");
  }
  return rtn;
}

bool SpecDoc::Execute(){

  // check the output path
  if( this->GetOutputPath().length() == 0 ){
    // requires an output path to be set
    WriteMsg("Error: output path is not set for " +
             this->GetName() );
    Errno->SetError( CGERR_ERROR, this->GetName() +
                     " : Output path is not set " );
    return false;
  }

  // Get the correct DAG Level 1
  CoreGenDAG *D1 = DAG->GetDAGFromLevel(this->GetLevel());
  if( D1 == nullptr ){
    WriteMsg( "Error obtaining DAG Level " + std::to_string(this->GetLevel()));
    Errno->SetError( CGERR_ERROR, this->GetName() +
                     " : Error obtaining DAG Level " +
                     std::to_string(this->GetLevel()));
    return false;
  }

  // Write the makefile
  if( !WriteMakefile() ){
    return false;
  }

  // Write the tex file
  if( !WriteTexfile(D1) ){
    return false;
  }

  return true;
}

// EOF
