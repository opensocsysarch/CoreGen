//
// _SCVLIWPipeBuilder_cpp_
//
// Copyright (C) 2017-2022 Tactical Computing Laboratories, LLC
// All Rights Reserved
// contact@tactcomplabs.com
//
// See LICENSE in the top level directory for licensing details
//

#include "CoreGen/StoneCutter/Passes/SCVLIWPipeBuilder.h"
#include "CoreGen/StoneCutter/SCMsg.h"

SCVLIWPipeBuilder::SCVLIWPipeBuilder(Module *TM,
                     SCOpts *O,
                     SCMsg *M)
  : SCPass("VLIWPipeBuilder","",TM,O,M) {
}

SCVLIWPipeBuilder::~SCVLIWPipeBuilder(){
}

bool SCVLIWPipeBuilder::Execute(){
  if( !TheModule ){
    this->PrintMsg( L_ERROR, "LLVM IR Module is null" );
    return false;
  }

  //
  // Notes from JDL:
  //
  // There are a number of potential paths here.
  //
  // First, there are two paths for VLIW:
  //
  // 1. specify the bundle types in the CoreGen+StoneCutter files (not yet done)
  //
  // 2. utilize the StoneCutter functions defined as 'VLIW' with the In/Out
  //    intrinsics in order to determine how the pipelines are wired up.
  //
  // We should make a decision whether you can mix these concepts.
  // For (1), we should be able to quickly determine whether the bundle
  // specifications are there.  In which case, we can effectively utilize
  // the pipeline logic generated by the SCPipeBuilder to handle the
  // normal pipelines and the SCVLIWPipeBuilder to wire the top-level
  // pipeline together (crack+decode; dispatch)
  //
  // For (2), we'll need to first use the function names to wire up
  // how the pipeline(s) are connected STAGE_x where `x1 defines the
  // stage number (monotonically increasing).  Then we can utilize the
  // In/Out intrinsics to determine "how" they're wired together
  // (control/data paths).  If we find functions w/o In/Out intrinsics, we'll
  // need to try and derive how they're wired up.  If we can't derive them, then
  // we'll need to error out
  //
  //
  // We don't necessarily need to utilize the same methods employed in the
  // existing SCPipeBuilder.
  //

#if 0
  // TODO: Not sure if InstVect should use the same as PipeBuilder... seems like a BundleParser that would look at the sigmap may be more appropriate
  VLIWPipeVect = SigMap->GetVLIWPipeVect();
  // BundleVect = SigMap->GetBundleVect();
  // InstVect = ParseBundles();

  // Enable SubPasses (TODO: VLIW Specific?)
  if( !EnableSubPasses() ) {
    this->PrintMsg( L_ERROR, "Could not initialize VLIW sub-passes");
    return false;
  }
  // Initalize the attribute map (TODO: This would remain the same process just different attributes... I think)
  if( !InitAttrs() ){
    this->PrintMsg( L_ERROR, "Could not initialize attributes" );
    return false;
  }

  // TODO: Would there be a matrix? VLIW Payload won't have crack & decode yet
  // allocate the matrix
  if( !AllocMat() ){
    this->PrintMsg( L_ERROR, "Could not allocate matrix" );
    return false;
  }

  // build the pipeline matrix (TODO: This should be replaced by a bundle scheduler... is In/Out the only constraints a user can specify?)
  if( !BuildMat() ){
    this->PrintMsg( L_ERROR, "Could not build matrix representation of pipeline" );
    FreeMat();
    return false;
  }

  // execute optimizations (TODO: We should be able to use this as is w/ different passes enabled of course)
  if( !Optimize() ){
    this->PrintMsg( L_ERROR, "Encountered errors executing the the optimization phases" );
    FreeMat();
    return false;
  }

  // write everything back to the sigmap (TODO: This should be able to be used as well, just maybe specifying which pipeline to write back to?)
  if( !WriteSigMap() ){
    this->PrintMsg( L_ERROR, "Could not write signal map for the prescribed pipeline" );
    FreeMat();
    return false;
  }

  // free the matrix
  if( !FreeMat() ){
    this->PrintMsg( L_ERROR, "Could not free adjacency matrix" );
    return false;
  }

#endif
  return true;
}

// EOF

